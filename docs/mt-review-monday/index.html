<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Midterm Review: Grouping, Pivoting, Imputation, and Web Scraping</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="../assets/theme.css" />
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css" />
</head>
<body>
<header id="title-block-header">
<h1 class="title">Midterm Review: Grouping, Pivoting, Imputation, and
Web Scraping</h1>
</header>
<p><link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>
<!-- add after bootstrap.min.css -->
<link rel="stylesheet" href="https://cdn.rawgit.com/afeld/bootstrap-toc/v1.0.1/dist/bootstrap-toc.min.css"/>
<!-- add after bootstrap.min.js or bootstrap.bundle.min.js -->
<script src="https://cdn.rawgit.com/afeld/bootstrap-toc/v1.0.1/dist/bootstrap-toc.min.js"></script></p>
<!-- for difficulty gauges-->
<script src="https://cdn.plot.ly/plotly-2.16.1.min.js"></script>
<!-- Global site tag (gtag.js) - Google Analytics -->
<!-- <script async src="https://www.googletagmanager.com/gtag/js?id=G-B947E6J6H4"></script> -->
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  // gtag('js', new Date());

  // gtag('config', 'G-B947E6J6H4');
</script>
<p><a href="../index.html">← return to study.practicaldsc.org</a></p>
<hr />
<p>The problems in this worksheet are taken from past exams in similar
classes. Work on them <strong>on paper</strong>, since the exams you
take in this course will also be on paper. <br><br>We encourage you to
attempt these problems <strong>before</strong> Monday’s exam review
session, so that we have enough time to walk through the solutions to
all of the problems. <br><br>We will enable the solutions here after the
review session, though you can find the written solutions to these
problems in other discussion worksheets.</p>
<hr />
<h2 id="problem-1">Problem 1</h2>
<p>For this question, we will work with the DataFrame <code>tv</code>,
which contains information about various TV shows available to watch on
streaming services. For each TV show, we have:</p>
<ul>
<li><code>"Title" (object)</code>: The title of the TV show.</li>
<li><code>"Year" (int)</code>: The year in which the TV show was first
released. (For instance, the show <em>How I Met Your Mother</em> ran
from 2005 to 2014; there is only one row for <em>How I Met Your
Mother</em> in <code>tv</code>, and its <code>"Year"</code> value is
2005.)</li>
<li><code>"Age" (object)</code>: The age category for the TV show. If
not missing, <code>"Age"</code> is one of <code>"all"</code>,
<code>"7+"</code>, <code>"13+"</code>, <code>"16+"</code>, or
<code>"18+"</code>. (For instance, <code>"all"</code> means that the
show is appropriate for all audiences, while `“18+”} means that the show
contains mature content and viewers should be at least 18 years
old.)</li>
<li><code>"IMDb" (float)</code>: The TV show’s rating on IMDb (between 0
and 10).</li>
<li><code>"Rotten Tomatoes" (int)</code>: The TV show’s rating on Rotten
Tomatoes (between 0 and 100).</li>
<li><code>"Netflix" (int)</code>: 1 if the show is available for
streaming on Netflix and 0 otherwise. The <code>"Hulu"</code>,
<code>"Prime Video"</code>, and <code>"Disney+"</code> columns work the
same way.</li>
</ul>
<p>The first few rows of <code>tv</code> are shown below (though
<code>tv</code> has many more rows than are pictured here).</p>
<center><img src='../assets/images/disc02/disc02-p4-df.png' width=65%></center>
<p>Assume that we have already run all of the necessary imports.</p>
<p><strong>Throughout this problem, we will refer to <code>tv</code>
repeatedly.</strong></p>
<p>In the following subparts, consider the variable
<code>double_count</code>, defined below.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>double_count <span class="op">=</span> tv[<span class="st">&quot;Title&quot;</span>].value_counts().value_counts()</span></code></pre></div>
<p><br></p>
<h3 id="problem-1.1">Problem 1.1</h3>
<p>What is <code>type(double_count)</code>?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> Series</p></li>
<li><p><input type="radio" disabled="" /> SeriesGroupBy</p></li>
<li><p><input type="radio" disabled="" /> DataFrame</p></li>
<li><p><input type="radio" disabled="" /> DataFrameGroupBy</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading1_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse1_1" aria-expanded="true" aria-controls="collapse1_1">
Click to view the solution.
</button>
</h2>
<div id="collapse1_1" class="accordion-collapse collapse"
aria-labelledby="heading1_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer</strong>: Series</p>
<p>The <code>.value_counts()</code> method, when called on a Series
<code>s</code>, produces a new Series in which</p>
<ul>
<li>the index contains all unique values in <code>s</code>.</li>
<li>the values are the frequencies of the unique values in
<code>s</code>.</li>
</ul>
<p>Since <code>tv["Title"]</code> is a Series,
<code>tv["Title"].value_counts()</code> is a Series, and so is
<code>tv["Title"].value_counts.value_counts()</code>. We provide an
interpretation of each of these Series in the solution to the next
subpart.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-1.2">Problem 1.2</h3>
<p>Which of the following statements are true? Select all that
apply.</p>
<ul class="task-list">
<li><p><input type="checkbox" disabled="" /> The only case in which it would make sense to set the index of
<code>tv</code> to <code>"Title"</code> is if
<code>double_count.iloc[0] == 1</code> is <code>True</code>.</p></li>
<li><p><input type="checkbox" disabled="" /> The only case in which it would make sense to set the index of
<code>tv</code> to <code>"Title"</code> is if
<code>double_count.loc[1] == tv.shape[0]</code> is
<code>True</code>.</p></li>
<li><p><input type="checkbox" disabled="" /> If <code>double_count.loc[2] == 5</code> is <code>True</code>, there
are 5 TV shows that all share the same <code>"Title"</code>.</p></li>
<li><p><input type="checkbox" disabled="" /> If <code>double_count.loc[2] == 5</code> is <code>True</code>, there
are 5 pairs of 2 TV shows such that each pair shares the same
<code>"Title"</code>.</p></li>
<li><p><input type="checkbox" disabled="" /> None of the above.</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading1_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse1_2" aria-expanded="true" aria-controls="collapse1_2">
Click to view the solution.
</button>
</h2>
<div id="collapse1_2" class="accordion-collapse collapse"
aria-labelledby="heading1_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answers</strong>:</p>
<ul>
<li>The only case in which it would make sense to set the index of
<code>tv</code> to <code>"Title"</code> is if
<code>double_count.loc[1] == tv.shape[0]</code> is
<code>True</code>.</li>
<li>If <code>double_count.loc[2] == 5</code> is <code>True</code>, there
are 5 pairs of 2 TV shows such that each pair shares the same
<code>"Title"</code>.</li>
</ul>
<p>To answer, we need to understand what each of
<code>tv["Title"]</code>, <code>tv["Title"].value_counts()</code>, and
<code>tv["Title"].value_counts().value_counts()</code> contain. To
illustrate, let’s start with a basic, unrelated example. Suppose
<code>tv["Title"]</code> looks like:</p>
<div id="cb1" class="sourceCode">
<pre class="sourceCode py"><code class="sourceCode python"><span id="cb1-1"><a aria-hidden="true" href="#cb1-1" tabindex="-1"></a><span class="dv">0</span>    A</span>
<span id="cb1-2"><a aria-hidden="true" href="#cb1-2" tabindex="-1"></a><span class="dv">1</span>    B</span>
<span id="cb1-3"><a aria-hidden="true" href="#cb1-3" tabindex="-1"></a><span class="dv">2</span>    C</span>
<span id="cb1-4"><a aria-hidden="true" href="#cb1-4" tabindex="-1"></a><span class="dv">3</span>    B</span>
<span id="cb1-5"><a aria-hidden="true" href="#cb1-5" tabindex="-1"></a><span class="dv">4</span>    D</span>
<span id="cb1-6"><a aria-hidden="true" href="#cb1-6" tabindex="-1"></a><span class="dv">5</span>    E</span>
<span id="cb1-7"><a aria-hidden="true" href="#cb1-7" tabindex="-1"></a><span class="dv">6</span>    A</span>
<span id="cb1-8"><a aria-hidden="true" href="#cb1-8" tabindex="-1"></a>dtype: <span class="bu">object</span></span></code></pre>
</div>
<p>Then, <code>tv["Title"].value_counts()</code> looks like:</p>
<div id="cb2" class="sourceCode">
<pre class="sourceCode py"><code class="sourceCode python"><span id="cb2-1"><a aria-hidden="true" href="#cb2-1" tabindex="-1"></a>A    <span class="dv">2</span></span>
<span id="cb2-2"><a aria-hidden="true" href="#cb2-2" tabindex="-1"></a>B    <span class="dv">2</span></span>
<span id="cb2-3"><a aria-hidden="true" href="#cb2-3" tabindex="-1"></a>C    <span class="dv">1</span></span>
<span id="cb2-4"><a aria-hidden="true" href="#cb2-4" tabindex="-1"></a>D    <span class="dv">1</span></span>
<span id="cb2-5"><a aria-hidden="true" href="#cb2-5" tabindex="-1"></a>E    <span class="dv">1</span></span>
<span id="cb2-6"><a aria-hidden="true" href="#cb2-6" tabindex="-1"></a>dtype: int64</span></code></pre>
</div>
<p>and <code>tv["Title"].value_counts().value_counts()</code> looks
like:</p>
<div id="cb3" class="sourceCode">
<pre class="sourceCode py"><code class="sourceCode python"><span id="cb3-1"><a aria-hidden="true" href="#cb3-1" tabindex="-1"></a><span class="dv">1</span>    <span class="dv">3</span></span>
<span id="cb3-2"><a aria-hidden="true" href="#cb3-2" tabindex="-1"></a><span class="dv">2</span>    <span class="dv">2</span></span>
<span id="cb3-3"><a aria-hidden="true" href="#cb3-3" tabindex="-1"></a>dtype: int64</span></code></pre>
</div>
<p>Back to our actual dataset. <code>tv["Title"]</code>, as we know,
contains the name of each TV show.
<code>tv["Title"].value_counts()</code> is a Series whose index is a
sequence of the unique TV show titles in <code>tv["Title"]</code>, and
whose values are the frequencies of each title.
<code>tv["Title"].value_counts()</code> may look something like the
following:</p>
<div id="cb4" class="sourceCode">
<pre class="sourceCode py"><code class="sourceCode python"><span id="cb4-1"><a aria-hidden="true" href="#cb4-1" tabindex="-1"></a>Breaking Bad                             <span class="dv">1</span></span>
<span id="cb4-2"><a aria-hidden="true" href="#cb4-2" tabindex="-1"></a>Fresh Meat                               <span class="dv">1</span></span>
<span id="cb4-3"><a aria-hidden="true" href="#cb4-3" tabindex="-1"></a>Doctor Thorne                            <span class="dv">1</span></span>
<span id="cb4-4"><a aria-hidden="true" href="#cb4-4" tabindex="-1"></a>                                       ...</span>
<span id="cb4-5"><a aria-hidden="true" href="#cb4-5" tabindex="-1"></a>Styling Hollywood                        <span class="dv">1</span></span>
<span id="cb4-6"><a aria-hidden="true" href="#cb4-6" tabindex="-1"></a>Vai Anitta                               <span class="dv">1</span></span>
<span id="cb4-7"><a aria-hidden="true" href="#cb4-7" tabindex="-1"></a>Fearless Adventures <span class="cf">with</span> Jack Randall    <span class="dv">1</span></span>
<span id="cb4-8"><a aria-hidden="true" href="#cb4-8" tabindex="-1"></a>Name: Title, Length: <span class="dv">5368</span>, dtype: int64</span></code></pre>
</div>
<p>Then, <code>tv["Title"].value_counts().value_counts()</code> is a
Series whose index is a sequence of the unique values in the above
Series, and whose values are the frequencies of each value above. In the
case where all titles in <code>tv["Title"]</code> are unique, then
<code>tv["Title"].value_counts()</code> will only have one unique value,
1, repeated many times. Then,
<code>tv["Title"].value_counts().value_counts()</code> will only have
one row total, and will look something like:</p>
<div id="cb5" class="sourceCode">
<pre class="sourceCode py"><code class="sourceCode python"><span id="cb5-1"><a aria-hidden="true" href="#cb5-1" tabindex="-1"></a><span class="dv">1</span>    <span class="dv">5368</span></span>
<span id="cb5-2"><a aria-hidden="true" href="#cb5-2" tabindex="-1"></a>Name: Title, dtype: int64</span></code></pre>
</div>
<p>This allows us to distinguish between the first two answer choices.
The key is remembering that <strong>in order to set a column to the
index, the column should only contain unique values</strong>, since the
goal of the index is to provide a “name” (more formally, a label) for
each row.</p>
<ul>
<li>The first answer choice, “The only case in which it would make sense
to set the index of <code>tv</code> to <code>"Title"</code> is if
<code>double_count.iloc[0] == 1</code> is <code>True</code>”, is false.
As we can see in the example above, all titles are unique, but
<code>double_count.iloc[0]</code> is something other than 1.</li>
<li>The second answer choice, “The only case in which it would make
sense to set the index of <code>tv</code> to <code>"Title"</code> is if
<code>double_count.loc[1] == tv.shape[0]</code> is <code>True</code>”,
is true. If <code>double_count.loc[1] == tv.shape[0]</code>, it means
that all values in <code>tv["Title"].value_counts()</code> were 1,
meaning that <code>tv["Title"]</code> consisted solely of unique values,
which is the only case in which it makes sense to set
<code>"Title"</code> to the index.</li>
</ul>
<p>Now, let’s look at the second two answer choices. If
<code>double_counts.loc[2] == 5</code>, it would mean that 5 of the
values in <code>tv["Title"].value_counts()</code> were 2. This would
mean that there were 5 pairs of titles in <code>tv["Title"]</code> that
were the same.</p>
<ul>
<li>This makes the fourth answer choice, “If
<code>double_count.loc[2] == 5</code> is <code>True</code>, there are 5
pairs of 2 TV shows such that each pair shares the same
<code>"Title"</code>”, correct.</li>
<li>The third answer choice, “If <code>double_count.loc[2] == 5</code>
is <code>True</code>, there are 5 TV shows that all share the same
<code>"Title"</code>”, is incorrect; if there were 5 TV shows with the
same title, then <code>double_count.loc[5]</code> would be at least 1,
but we can’t make any guarantees about
<code>double_counts.loc[2]</code>.</li>
</ul>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-1.3">Problem 1.3</h3>
<p>Ethan is an avid Star Wars fan, and the only streaming service he has
an account on is Disney+. (He had a Netflix account, but then Netflix
cracked down on password sharing.)</p>
<p>Fill in the blanks below so that <code>star_disney_prop</code>
evaluates to the proportion of TV shows in <code>tv</code> with
<code>"Star Wars"</code> in the title that are available to stream on
Disney+.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>star_only <span class="op">=</span> __(a)__</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>star_disney_prop <span class="op">=</span> __(b)__ <span class="op">/</span> star_only.shape[<span class="dv">0</span>]</span></code></pre></div>
<p>What goes in the blanks?</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading1_3">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse1_3" aria-expanded="true" aria-controls="collapse1_3">
Click to view the solution.
</button>
</h2>
<div id="collapse1_3" class="accordion-collapse collapse"
aria-labelledby="heading1_3" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answers</strong>:</p>
<ul>
<li>Blank (a):
<code>tv[tv["Title"].str.contains("Star Wars")]</code></li>
<li>Blank (b): <code>star_only["Disney+"].sum()</code></li>
</ul>
<p>We’re asked to find the proportion of TV shows with
<code>"Star Wars"</code> in the title that are available to stream on
Disney+. This is a fraction, where:</p>
<ul>
<li>The numerator is the number of TV shows that have
<code>"Star Wars"</code> in the title <strong>and</strong> are available
to stream on Disney+.</li>
<li>The denominator is the number of TV shows that have
<code>"Star Wars"</code> in the title.</li>
</ul>
<p>The key is recognizing that <code>star_only</code> must be a
DataFrame that contains all the rows in which the <code>"Title"</code>
contains <code>"Star Wars"</code>; to create this DataFrame in blank
(a), we use <code>tv[tv["Title"].str.contains("Star Wars")]</code>.
Then, the denominator is already provided for us, and all we need to
fill in is the numerator. There are a few possibilities, though they all
include <code>star_only</code>:</p>
<ul>
<li><code>star_only["Disney+"].sum()</code></li>
<li><code>(star_only["Disney+"] == 1).sum()</code></li>
<li><code>star_only[star_only["Disney+"] == 1].shape[0]</code></li>
</ul>
<p><strong>Common misconception</strong>: Many students calculated the
wrong proportion: they calculated the proportion of shows available to
stream on Disney+ that have <code>"Star Wars"</code> in the title. We
asked for the proportion of shows with <code>"Star Wars"</code> in the
title that are available to stream on Disney+; “proportion of <span class="math inline">X</span> that <span class="math inline">Y</span>” is
always <span class="math inline">\frac{\# X \text{ and } Y}{\#
X}</span>.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<h2 id="problem-2">Problem 2</h2>
<p>In this problem, we will be using the following DataFrame
<code>students</code>, which contains various information about high
school students and the university/universities they applied to.</p>
<center><img src='../assets/images/disc04/students.png' width=65%></center>
<p>The columns are:</p>
<ul>
<li><code>'Name' (str)</code>: the name of the student.</li>
<li><code>'High School' (str)</code>: the High School that the student
attended.</li>
<li><code>'Email' (str)</code>: the email of the student.</li>
<li><code>'GPA' (float)</code>: the GPA of the student.</li>
<li><code>'AP' (int)</code>: the number of AP exams that the student
took.</li>
<li><code>'University' (str)</code>: the name of the university that the
student applied to.</li>
<li><code>'Admit' (str)</code>: the acceptance status of the student
(where ‘Y’ denotes that they were accepted to the university and ‘N’
denotes that they were not).</li>
</ul>
<p>The rows of <code>'student'</code> are arranged in no particular
order. The first eight rows of <code>'student'</code> are shown above
(though <code>'student'</code> has many more rows than pictured
here).</p>
<p><br></p>
<h3 id="problem-2.1">Problem 2.1</h3>
<p>Fill in the blank so that the result evaluates to a Series indexed by
<code>"Email"</code> that contains a <strong>list</strong> of the
universities that each student <strong>was admitted to</strong>. If a
student wasn’t admitted to any universities, they should have an empty
list.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>    students.groupby(<span class="st">&quot;Email&quot;</span>).<span class="bu">apply</span>(_____)</span></code></pre></div>
<p>What goes in the blank?</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading2_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse2_1" aria-expanded="true" aria-controls="collapse2_1">
Click to view the solution.
</button>
</h2>
<div id="collapse2_1" class="accordion-collapse collapse"
aria-labelledby="heading2_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong>
<code>lambda df: df.loc[df["Admit"] == "Y", "University"].tolist()</code></p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-2.2">Problem 2.2</h3>
<p>Which of the following blocks of code correctly assign
<code>max_AP</code> to the maximum number of APs taken by a student who
was rejected by UC San Diego?</p>
<p>Option 1:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>cond1 <span class="op">=</span> students[<span class="st">&quot;Admit&quot;</span>] <span class="op">==</span> <span class="st">&quot;N&quot;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>cond2 <span class="op">=</span> students[<span class="st">&quot;University&quot;</span>] <span class="op">==</span> <span class="st">&quot;UC San Diego&quot;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>max_AP <span class="op">=</span> students.loc[cond1 <span class="op">&amp;</span> cond2, <span class="st">&quot;APs&quot;</span>].sort_values().iloc[<span class="op">-</span><span class="dv">1</span>]</span></code></pre></div>
<p>Option 2:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>cond1 <span class="op">=</span> students[<span class="st">&quot;Admit&quot;</span>] <span class="op">==</span> <span class="st">&quot;N&quot;</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>cond2 <span class="op">=</span> students[<span class="st">&quot;University&quot;</span>] <span class="op">==</span> <span class="st">&quot;UC San Diego&quot;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>d3 <span class="op">=</span> students.groupby([<span class="st">&quot;University&quot;</span>, <span class="st">&quot;Admit&quot;</span>]).<span class="bu">max</span>().reset_index()</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>max_AP <span class="op">=</span> d3.loc[cond1 <span class="op">&amp;</span> cond2, <span class="st">&quot;APs&quot;</span>].iloc[<span class="dv">0</span>]</span></code></pre></div>
<p>Option 3:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> students.pivot_table(index<span class="op">=</span><span class="st">&quot;Admit&quot;</span>, </span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>                            columns<span class="op">=</span><span class="st">&quot;University&quot;</span>, </span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>                            values<span class="op">=</span><span class="st">&quot;APs&quot;</span>, </span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>                            aggfunc<span class="op">=</span><span class="st">&quot;max&quot;</span>)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>max_AP <span class="op">=</span> p.loc[<span class="st">&quot;N&quot;</span>, <span class="st">&quot;UC San Diego&quot;</span>]</span></code></pre></div>
<p>Option 4:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># .last() returns the element at the end of a Series it is called on</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>groups <span class="op">=</span> students.sort_values([<span class="st">&quot;APs&quot;</span>, <span class="st">&quot;Admit&quot;</span>]).groupby(<span class="st">&quot;University&quot;</span>)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>max_AP <span class="op">=</span> groups[<span class="st">&quot;APs&quot;</span>].last()[<span class="st">&quot;UC San Diego&quot;</span>]</span></code></pre></div>
<p><strong>Select all that apply.</strong> There is at least one correct
option.</p>
<ul class="task-list">
<li><p><input type="checkbox" disabled="" /> Option 1</p></li>
<li><p><input type="checkbox" disabled="" /> Option 2</p></li>
<li><p><input type="checkbox" disabled="" /> Option 3</p></li>
<li><p><input type="checkbox" disabled="" /> Option 4</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading2_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse2_2" aria-expanded="true" aria-controls="collapse2_2">
Click to view the solution.
</button>
</h2>
<div id="collapse2_2" class="accordion-collapse collapse"
aria-labelledby="heading2_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> Option 1 and Option 3</p>
<ul>
<li><p>Option 1 works correctly, it is probably the most straightforward
way of answering the question. <code>cond1</code> is <code>True</code>
for all rows in which students were rejected, and <code>cond2</code> is
<code>True</code> for all rows in which students applied to UCSD. As
such, <code>students.loc[cond1 &amp; cond2]</code> contains only the
rows where students were rejected from UCSD. Then,
<code>students.loc[cond1 &amp; cond2, "APs"].sort_values()</code> sorts
by the number of <code>"APs"</code> taken in increasing order, and
<code>.iloc[-1]</code> gets the largest number of <code>"APs"</code>
taken.</p></li>
<li><p>Option 2 doesn’t work because the lengths of <code>cond1</code>
and <code>cond2</code> are not the same as the length of
<code>d3</code>, so this causes an error.</p></li>
<li><p>Option 3 works correctly. For each combination of
<code>"Admit"</code> status (<code>"Y"</code>, <code>"N"</code>,
<code>"W"</code>) and <code>"University"</code> (including UC San
Diego), it computes the max number of <code>"APs"</code>. The usage of
<code>.loc["N", "UC San Diego"]</code> is correct too.</p></li>
<li><p>Option 4 doesn’t work. It currently returns the maximum number of
<code>"APs"</code> taken by someone who applied to UC San Diego; it does
not factor in whether they were admitted, rejected, or
waitlisted.</p></li>
</ul>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-2.3">Problem 2.3</h3>
<p>Currently, <code>students</code> has a lot of repeated information —
for instance, if a student applied to 10 universities, their GPA appears
10 times in <code>students</code>.</p>
<p>We want to generate a DataFrame that contains a single row for each
student, indexed by <code>"Email"</code>, that contains their
<code>"Name"</code>, <code>"High School"</code>, <code>"GPA"</code>, and
<code>"APs"</code>.</p>
<p>One attempt to create such a DataFrame is below.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>students.groupby(<span class="st">&quot;Email&quot;</span>).aggregate({<span class="st">&quot;Name&quot;</span>: <span class="st">&quot;max&quot;</span>,</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>                                        <span class="st">&quot;High School&quot;</span>: <span class="st">&quot;mean&quot;</span>,</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>                                        <span class="st">&quot;GPA&quot;</span>: <span class="st">&quot;mean&quot;</span>,</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>                                        <span class="st">&quot;APs&quot;</span>: <span class="st">&quot;max&quot;</span>})</span></code></pre></div>
<p>There is exactly one issue with the line of code above. <strong>In
one sentence</strong>, explain what needs to be changed about the line
of code above so that the desired DataFrame is created.</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading2_3">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse2_3" aria-expanded="true" aria-controls="collapse2_3">
Click to view the solution.
</button>
</h2>
<div id="collapse2_3" class="accordion-collapse collapse"
aria-labelledby="heading2_3" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> The problem right now is that aggregating
High School by mean doesn’t work since you can’t aggregate a column with
strings using <code>"mean"</code>. Thus changing it to something that
works for strings like <code>"max"</code> or <code>"min"</code> would
fix the issue.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-2.4">Problem 2.4</h3>
<p>Consider the following snippet of code.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>pivoted <span class="op">=</span> students.assign(Admit<span class="op">=</span>students[<span class="st">&quot;Admit&quot;</span>] <span class="op">==</span> <span class="st">&quot;Y&quot;</span>) <span class="op">\</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>                    .pivot_table(index<span class="op">=</span><span class="st">&quot;High School&quot;</span>, </span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>                                columns<span class="op">=</span><span class="st">&quot;University&quot;</span>, </span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>                                values<span class="op">=</span><span class="st">&quot;Admit&quot;</span>, </span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>                                aggfunc<span class="op">=</span><span class="st">&quot;sum&quot;</span>)</span></code></pre></div>
<p>Some of the rows and columns of <code>pivoted</code> are shown
below.</p>
<center><img src='../assets/images/disc04/pivot.png' width=55%></center>
<p>No students from Warren High were admitted to Columbia or Stanford.
However,<br />
<code>pivoted.loc["Warren High", "Columbia"]</code> and
<code>pivoted.loc["Warren High", "Stanford"]</code> evaluate to
different values. What is the reason for this difference?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> Some students from Warren High applied to Stanford, and some others
applied to Columbia, but none applied to both.</p></li>
<li><p><input type="radio" disabled="" /> Some students from Warren High applied to Stanford but none applied
to Columbia.</p></li>
<li><p><input type="radio" disabled="" /> Some students from Warren High applied to Columbia but none applied
to Stanford.</p></li>
<li><p><input type="radio" disabled="" /> The students from Warren High that applied to both Columbia and
Stanford were all rejected from Stanford, but at least one was admitted
to Columbia.</p></li>
<li><p><input type="radio" disabled="" /> When using <code>pivot_table</code>, <code>pandas</code> was not able
to sum strings of the form <code>"Y"</code>, <code>"N"</code>, and
<code>"W"</code>, so the values in <code>pivoted</code> are
unreliable.</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading2_4">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse2_4" aria-expanded="true" aria-controls="collapse2_4">
Click to view the solution.
</button>
</h2>
<div id="collapse2_4" class="accordion-collapse collapse"
aria-labelledby="heading2_4" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> Option 3</p>
<p><code>pivoted.loc["Warren High", "Stanford"]</code> is
<code>NaN</code> because there were no rows in <code>students</code> in
which the <code>"High School"</code> was <code>"Warren High"</code> and
the <code>"University"</code> was <code>"Stanford"</code>, because
nobody from Warren High applied to Stanford. However,
<code>pivoted.loc["Warren High", "Columbia"]</code> is not
<code>NaN</code> because there was at least one row in
<code>students</code> in which the <code>"High School"</code> was
<code>"Warren High"</code> and the <code>"University"</code> was
<code>"Columbia"</code>. This means that at least one student from
Warren High applied to Columbia.</p>
<p>Option 3 is the only option consistent with this logic.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<h2 id="problem-3">Problem 3</h2>
<p>After taking the SAT, Nicole wants to check the College Board’s
website to see her score. However, the College Board recently updated
their website to use non-standard HTML tags and Nicole’s browser can’t
render it correctly. As such, she resorts to making a GET request to the
site with her scores on it to get back the source HTML and tries to
parse it with BeautifulSoup.</p>
<p>Suppose <code>soup</code> is a BeautifulSoup object instantiated
using the following HTML document.</p>
<pre><code>&lt;college&gt;Your score is ready!&lt;/college&gt;

&lt;sat verbal=&quot;ready&quot; math=&quot;ready&quot;&gt;
  Your percentiles are as follows:
  &lt;scorelist listtype=&quot;percentiles&quot;&gt;
    &lt;scorerow kind=&quot;verbal&quot; subkind=&quot;per&quot;&gt;
      Verbal: &lt;scorenum&gt;84&lt;/scorenum&gt;
    &lt;/scorerow&gt;
    &lt;scorerow kind=&quot;math&quot; subkind=&quot;per&quot;&gt;
      Math: &lt;scorenum&gt;99&lt;/scorenum&gt;
    &lt;/scorerow&gt;
  &lt;/scorelist&gt;
  And your actual scores are as follows:
  &lt;scorelist listtype=&quot;scores&quot;&gt;
    &lt;scorerow kind=&quot;verbal&quot;&gt; Verbal: &lt;scorenum&gt;680&lt;/scorenum&gt; &lt;/scorerow&gt;
    &lt;scorerow kind=&quot;math&quot;&gt; Math: &lt;scorenum&gt;800&lt;/scorenum&gt; &lt;/scorerow&gt;
  &lt;/scorelist&gt;
&lt;/sat&gt;</code></pre>
<p><br></p>
<h3 id="problem-3.1">Problem 3.1</h3>
<p>Which of the following expressions evaluate to <code>"verbal"</code>?
Select all that apply.</p>
<ul class="task-list">
<li><p><input type="checkbox" disabled="" /> <code>soup.find("scorerow").get("kind")</code></p></li>
<li><p><input type="checkbox" disabled="" /> <code>soup.find("sat").get("ready")</code></p></li>
<li><p><input type="checkbox" disabled="" /> <code>soup.find("scorerow").text.split(":")[0].lower()</code></p></li>
<li><p><input type="checkbox" disabled="" /> <code>[s.get("kind") for s in soup.find_all("scorerow")][-2]</code></p></li>
<li><p><input type="checkbox" disabled="" /> <code>soup.find("scorelist", attrs={"listtype":"scores"}).get("kind")</code></p></li>
<li><p><input type="checkbox" disabled="" /> None of the above</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading3_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse3_1" aria-expanded="true" aria-controls="collapse3_1">
Click to view the solution.
</button>
</h2>
<div id="collapse3_1" class="accordion-collapse collapse"
aria-labelledby="heading3_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> Option 1, Option 3, Option 4</p>
<p>Correct options:</p>
<ul>
<li>Option 1 finds the first <code>&lt;scorerow&gt;</code> element and
retrieves its <code>"kind"</code> attribute, which is
<code>"verbal"</code> for the first <code>&lt;scorerow&gt;</code>
encountered in the HTML document.</li>
<li>Option 2 finds the first <code>&lt;scorerow&gt;</code> tag,
retrieves its text <code>("Verbal: 84")</code>, splits this text by “:”,
and takes the first element of the resulting list
<code>("Verbal")</code>, converting it to lowercase to match
<code>"verbal"</code>.</li>
<li>Option 3 creates a list of <code>"kind"</code> attributes for all
<code>&lt;scorerow&gt;</code> elements. The second to last (-2) element
in this list corresponds to the <code>"kind"</code> attribute of the
first <code>&lt;scorerow&gt;</code> in the second
<code>&lt;scorelist&gt;</code> tag, which is also
<code>"verbal"</code>.</li>
</ul>
<p>Incorrect options:</p>
<ul>
<li>Option 2 attempts to get an attribute ready from the
<code>&lt;sat&gt;</code> tag, which does not exist as an attribute.</li>
<li>Option 5 tries to retrieve a <code>"kind"</code> attribute from a
<code>&lt;scorelist&gt;</code> tag, but <code>&lt;scorelist&gt;</code>
does not have a <code>"kind"</code> attribute.</li>
</ul>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-3.2">Problem 3.2</h3>
<p>Consider the following function.</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> summer(tree):</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">isinstance</span>(tree, <span class="bu">list</span>):</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>        total <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> subtree <span class="kw">in</span> tree:</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> s <span class="kw">in</span> subtree.find_all(<span class="st">&quot;scorenum&quot;</span>):</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>                total <span class="op">+=</span> <span class="bu">int</span>(s.text)</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> total</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">sum</span>([<span class="bu">int</span>(s.text) <span class="cf">for</span> s <span class="kw">in</span> tree.find_all(<span class="st">&quot;scorenum&quot;</span>)])</span></code></pre></div>
<p>For each of the following values, fill in the blanks to assign
<code>tree</code> such that <code>summer(tree)</code> evaluates to the
desired value. The first example has been done for you.</p>
<ul>
<li>Desired value: <code>84</code></li>
</ul>
<div class="sourceCode" id="cb12"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>    tree <span class="op">=</span> soup.find(<span class="st">&quot;scorerow&quot;</span>)</span></code></pre></div>
<ul>
<li>Desired value: <code>183</code></li>
</ul>
<div class="sourceCode" id="cb13"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>    tree <span class="op">=</span> soup.find(__a__)</span></code></pre></div>
<ul>
<li>Desired value: <code>1480</code></li>
</ul>
<div class="sourceCode" id="cb14"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>    tree <span class="op">=</span> soup.find(__b__)</span></code></pre></div>
<ul>
<li>Desired value: <code>899</code></li>
</ul>
<div class="sourceCode" id="cb15"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>    tree <span class="op">=</span> soup.find_all(__c__)</span></code></pre></div>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading3_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse3_2" aria-expanded="true" aria-controls="collapse3_2">
Click to view the solution.
</button>
</h2>
<div id="collapse3_2" class="accordion-collapse collapse"
aria-labelledby="heading3_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> a: <code>"scorelist"</code>, b:
<code>"scorelist", attrs={"listtype":"scores"}</code>, c:
<code>"scorerow", attrs={"kind":"math"}</code></p>
<p><code>soup.find("scorelist")</code> selects the first
<code>&lt;scorelist&gt;</code> tag, which includes both verbal and math
percentiles <code>(84 and 99)</code>. The function
<code>summer(tree)</code> sums these values to get <code>183</code>.</p>
<p>This selects the <code>&lt;scorelist&gt;</code> tag with
<code>listtype="scores"</code>, which contains the actual scores of
verbal <code>(680)</code> and math <code>(800)</code>. The function sums
these to get <code>1480</code>.</p>
<p>This selects all <code>&lt;scorerow&gt;</code>elements with
<code>kind="math"</code>, capturing both the percentile
<code>(99)</code> and the actual score <code>(800)</code>. Since tree is
now a list, <code>summer(tree)</code> iterates through each
<code>&lt;scorerow&gt;</code> in the list, summing their
<code>&lt;scorenum&gt;</code> values to reach <code>899</code>.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<h2 id="problem-4">Problem 4</h2>
<p>The EECS 398 staff are looking into hotels — some in San Diego, for
their family to stay at for graduation (and to eat Mexican food), and
some elsewhere, for summer trips.</p>
<p>Each row of <code>hotels</code> contains information about a
different hotel in San Diego. Specifically, for each hotel, we have:</p>
<ul>
<li><code>"Hotel Name" (str)</code>: The name of the hotel.
<strong>Assume hotel names are unique.</strong></li>
<li><code>"Location" (str):</code> The hotel’s neighborhood in San
Diego.</li>
<li><code>"Chain" (str):</code> The chain the hotel is a part of; either
<code>"Hilton", "Marriott", "Hyatt", or "Other".</code> A hotel chain is
a group of hotels owned or operated by a shared company.</li>
<li><code>"Number of Rooms" (int)</code>: The number of rooms the hotel
has.</li>
</ul>
<p>The first few rows of <code>hotels</code> are shown below, but hotels
has many more rows than are shown.</p>
<center><img src="../../assets/images/disc04/hotels.png" width=750></center>
<p>Now, consider the variable <code>summed</code>, defined below.</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>summed <span class="op">=</span> hotels.groupby(<span class="st">&quot;Chain&quot;</span>)[<span class="st">&quot;Number of Rooms&quot;</span>].<span class="bu">sum</span>().idxmax()</span></code></pre></div>
<p><br></p>
<h3 id="problem-4.1">Problem 4.1</h3>
<p>What is <code>type(summed)</code>?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> <code>int</code></p></li>
<li><p><input type="radio" disabled="" /> <code>str</code></p></li>
<li><p><input type="radio" disabled="" /> <code>Series</code></p></li>
<li><p><input type="radio" disabled="" /> <code>DataFrame</code></p></li>
<li><p><input type="radio" disabled="" /> <code>DataFrameGroupBy</code></p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading4_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse4_1" aria-expanded="true" aria-controls="collapse4_1">
Click to view the solution.
</button>
</h2>
<div id="collapse4_1" class="accordion-collapse collapse"
aria-labelledby="heading4_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> <code>str</code></p>
<p>When we do a <code>groupby</code> on the <code>Chain</code> column in
<code>hotels</code>, this means that the values in the
<code>Chain</code> column will be the indices of the DataFrame or Series
we get as output, in this case the Series
<code>hotels.groupby("Chain")["Number of Rooms"].sum()</code>.</p>
<p>Since the values of <code>Chain</code> are strings, and since
<code>.idxmax()</code> will return a value from the index of the
aforementioned Series, <code>summed</code> is a string.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-4.2">Problem 4.2</h3>
<p>In one sentence, explain what the value of <code>summed</code> means.
Phrase your explanation as if you had to give it to someone who is not a
data science major; that is, don’t say something like “it is the result
of grouping <code>hotels</code> by <code>"Chain"</code>, selecting the
<code>"Number of Rooms"</code> column, …”, but instead, give the value
context.</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading4_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse4_2" aria-expanded="true" aria-controls="collapse4_2">
Click to view the solution.
</button>
</h2>
<div id="collapse4_2" class="accordion-collapse collapse"
aria-labelledby="heading4_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> <code>summed</code> is the name of the hotel
chain with the most total rooms</p>
<p>The result of the <code>.groupby()</code> and <code>.sum()</code> is
a Series indexed by the unique <code>Chains</code>, whose values are the
total number of rooms in hotels owned by each chain. The
<code>idxmax()</code> function gets the index corresponding to the
largest value in the Series, which will be the hotel chain name with the
most total rooms.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-4.3">Problem 4.3</h3>
<p>Consider the variable <code>curious</code>, defined below.</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>curious <span class="op">=</span> frame[<span class="st">&quot;Chain&quot;</span>].value_counts().idxmax()</span></code></pre></div>
<p>Fill in the blank: <code>curious</code> is guaranteed to be equal to
<code>summed</code> only if <code>frame</code> has one row for every
____ in San Diego.</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> hotel</p></li>
<li><p><input type="radio" disabled="" /> hotel chain</p></li>
<li><p><input type="radio" disabled="" /> hotel room</p></li>
<li><p><input type="radio" disabled="" /> neighborhood</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading4_3">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse4_3" aria-expanded="true" aria-controls="collapse4_3">
Click to view the solution.
</button>
</h2>
<div id="collapse4_3" class="accordion-collapse collapse"
aria-labelledby="heading4_3" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> hotel room</p>
<p><code>curious</code> gets the most common value of <code>Chain</code>
in the DataFrame <code>frame</code>. We already know that
<code>summed</code> is the hotel chain with the most rooms in San Diego,
so <code>curious</code> only equals <code>summed</code> if the most
common <code>Chain</code> in <code>frame</code> is the hotel chain with
the most total rooms; this occurs when each row of <code>frame</code> is
a single hotel room.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-4.4">Problem 4.4</h3>
<p>Fill in the blanks so that <code>popular_areas</code> is an array of
the names of the unique neighborhoods that have at least 5 hotels and at
least 1000 hotel rooms.</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>    f <span class="op">=</span> <span class="kw">lambda</span> df: __(i)__</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    popular_areas <span class="op">=</span> (hotels</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>                    .groupby(__(ii)__)</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>                    .__(iii)__</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>                    __(iv)__)</span></code></pre></div>
<ol type="1">
<li><p>What goes in blank (i)?</p></li>
<li><p>What goes in blank (ii)?</p></li>
</ol>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> <code>"Hotel Name"</code></p></li>
<li><p><input type="radio" disabled="" /> <code>"Location"</code></p></li>
<li><p><input type="radio" disabled="" /> <code>"Chain"</code></p></li>
<li><p><input type="radio" disabled="" /> <code>"Number of Rooms"</code></p></li>
</ul>
<ol start="3" type="1">
<li>What goes in blank (iii)?</li>
</ol>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> <code>agg(f)</code></p></li>
<li><p><input type="radio" disabled="" /> <code>filter(f)</code></p></li>
<li><p><input type="radio" disabled="" /> <code>transform(f)</code></p></li>
</ul>
<ol start="4" type="1">
<li>What goes in blank (iv)?</li>
</ol>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading4_4">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse4_4" aria-expanded="true" aria-controls="collapse4_4">
Click to view the solution.
</button>
</h2>
<div id="collapse4_4" class="accordion-collapse collapse"
aria-labelledby="heading4_4" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answers</strong>:</p>
<ol type="1">
<li><code>df.shape[0] &gt;= 5 and df["Number of Rooms"].sum() &gt;= 1000</code></li>
<li><code>"Location"</code></li>
<li><code>filter(f)</code></li>
<li><code>["Location"].unique()</code> or equivalent</li>
</ol>
<p>We’d like to only consider certain neighborhoods according to group
characteristics (having &gt;= 5 hotels and &gt;= 1000 hotel rooms), and
<code>.filter()</code> allows us to do that by excluding groups not
meeting those criteria. So, we can write a function that evaluates those
criteria on one group at a time (the <code>df</code> of input to
<code>f</code> is the subset of <code>hotels</code> containing just one
<code>Location</code> value), and calling <code>filter(f)</code> means
that the only remaining rows are hotels in neighborhoods that match
those criteria. Finally, all we have to do is get the unique
neighborhoods from this DataFrame, which are the neighborhoods for which
<code>f</code> returned <code>True</code>.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-4.5">Problem 4.5</h3>
<p>Consider the code below.</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>    cond1 <span class="op">=</span> hotels[<span class="st">&quot;Chain&quot;</span>] <span class="op">==</span> <span class="st">&quot;Marriott&quot;</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    cond2 <span class="op">=</span> hotels[<span class="st">&quot;Location&quot;</span>] <span class="op">==</span> <span class="st">&quot;Coronado&quot;</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    combined <span class="op">=</span> hotels[cond1].merge(hotels[cond2], on<span class="op">=</span><span class="st">&quot;Hotel Name&quot;</span>, how<span class="op">=</span>???)</span></code></pre></div>
<ol type="1">
<li>If we replace <code>???</code> with <code>"inner"</code> in the code
above, which of the following will be equal to
<code>combined.shape[0]</code>?</li>
</ol>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> <code>min(cond1.sum(), cond2.sum())</code></p></li>
<li><p><input type="radio" disabled="" /> <code>(cond1 &amp; cond2).sum()</code></p></li>
<li><p><input type="radio" disabled="" /> <code>cond1.sum() + cond2.sum()</code></p></li>
<li><p><input type="radio" disabled="" /> <code>cond1.sum() + cond2.sum() - (cond1 &amp; cond2).sum()</code></p></li>
<li><p><input type="radio" disabled="" /> <code>cond1.sum() + (cond1 &amp; cond2).sum()</code></p></li>
</ul>
<ol start="2" type="1">
<li>If we replace <code>???</code> with <code>"outer"</code> in the code
above, which of the following will be equal to
<code>combined.shape[0]</code>?</li>
</ol>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> <code>min(cond1.sum(), cond2.sum())</code></p></li>
<li><p><input type="radio" disabled="" /> <code>(cond1 &amp; cond2).sum()</code></p></li>
<li><p><input type="radio" disabled="" /> <code>cond1.sum() + cond2.sum()</code></p></li>
<li><p><input type="radio" disabled="" /> <code>cond1.sum() + cond2.sum() - (cond1 &amp; cond2).sum()</code></p></li>
<li><p><input type="radio" disabled="" /> <code>cond1.sum() + (cond1 &amp; cond2).sum()</code></p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading4_5">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse4_5" aria-expanded="true" aria-controls="collapse4_5">
Click to view the solution.
</button>
</h2>
<div id="collapse4_5" class="accordion-collapse collapse"
aria-labelledby="heading4_5" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answers</strong>:</p>
<ol type="1">
<li><code>(cond1 &amp; cond2).sum()</code></li>
<li><code>cond1.sum() + cond2.sum() - (cond1 &amp; cond2).sum()</code></li>
</ol>
<p>Note that <code>cond1</code> and <code>cond2</code> are boolean
Series, and <code>hotels[cond1]</code> and <code>hotels[cond2]</code>
are the subsets of <code>hotels</code> where
<code>Chain == "Marriott</code> and
<code>"Location" == "Coronado"</code>, respectively.</p>
<ol type="1">
<li><p>When we perform an inner merge, we’re selecting every row where a
<code>Hotel Name</code> appears in <em>both</em>
<code>hotels[cond1]</code> and <code>hotels[cond2]</code>. This is the
same set of indices (and therefore hotel names, since those are unique)
as where <code>(cond1 &amp; cond2) == True</code>. So, the length of
<code>combined</code> will be the same as the number of
<code>True</code>s in <code>(cond1 &amp; cond2)</code>.</p></li>
<li><p>When we perform an outer merge, we’re selecting every row that
appears in <em>either</em> DataFrame, although there will not be repeats
for hotels that are both Marriott properties and are in Coronado. So, to
find the total number of rows in either DataFrame, we take the sum of
the sizes of each, and subtract rows that appear in both, which
corresponds to answer
<code>cond1.sum() + cond2.sum() - (cond1 &amp; cond2).sum()</code>.</p></li>
</ol>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<h2 id="problem-5">Problem 5</h2>
<p>Pranavi proposes the following imputation scheme.</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> impute(s):</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> s.fillna(np.random.choice(s[s.notna()]))</span></code></pre></div>
<p><br></p>
<h3 id="problem-5.1">Problem 5.1</h3>
<p><strong>True or False:</strong> <code>impute</code> performs
probabilistic imputation, using the same definition of probabilistic
imputation we learned about in class.</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> True</p></li>
<li><p><input type="radio" disabled="" /> False</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading5_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse5_1" aria-expanded="true" aria-controls="collapse5_1">
Click to view the solution.
</button>
</h2>
<div id="collapse5_1" class="accordion-collapse collapse"
aria-labelledby="heading5_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> False</p>
<p>In <code>impute</code>, <code>np.random.choice</code> will return a
single non-null value from <code>s</code>, and <code>.fillna()</code>
will fill every null value with this single value. Meanwhile,
probabilistic imputation draws a different value from a specified
distribution to fill each missing value, making it such that there won’t
be a single “spike” in the imputed distribution at a single chosen
value.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-5.2">Problem 5.2</h3>
<p>Consider the following expressions and values.</p>
<pre><code>    &gt;&gt;&gt; vals.isna().mean()
    0.2
    &gt;&gt;&gt; vals.describe().loc[[&quot;min&quot;, &quot;mean&quot;, &quot;max&quot;]]
    min     2.0
    mean    4.0
    max     7.0
    dtype: float64</code></pre>
<p>Given the above, what is the <strong>maximum</strong> possible value
of <code>impute(vals).mean()</code>? Give your answer as a number
rounded to one decimal place.</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading5_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse5_2" aria-expanded="true" aria-controls="collapse5_2">
Click to view the solution.
</button>
</h2>
<div id="collapse5_2" class="accordion-collapse collapse"
aria-labelledby="heading5_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> 4.6</p>
<p>The maximum possible value of <code>impute(vals).mean()</code> would
occur when every single missing value in <code>vals</code> is filled in
with the highest possible non-null value in <code>vals</code>. (As
discussed in the previous solution, <code>impute</code> selects only one
value from <code>s</code> to fill into every missing space.)</p>
<p>If this occurs, then the mean of the imputed Series will be weighted
mean of the available data and the filled data, and given the numbers in
the question, this is <span class="math inline">0.8 \cdot 4 + 0.2 \cdot
7</span>, or 4.6.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-5.3">Problem 5.3</h3>
<p>Which of the following statements below will always evaluate to
<code>True</code>?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> <code>vals.std() &lt; impute(vals).std()</code></p></li>
<li><p><input type="radio" disabled="" /> <code>vals.std() &lt;= impute(vals).std()</code></p></li>
<li><p><input type="radio" disabled="" /> <code>vals.std() == impute(vals).std()</code></p></li>
<li><p><input type="radio" disabled="" /> <code>vals.std() &gt;= impute(vals).std()</code></p></li>
<li><p><input type="radio" disabled="" /> <code>vals.std() &gt; impute(vals).std()</code></p></li>
<li><p><input type="radio" disabled="" /> None of the above</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading5_3">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse5_3" aria-expanded="true" aria-controls="collapse5_3">
Click to view the solution.
</button>
</h2>
<div id="collapse5_3" class="accordion-collapse collapse"
aria-labelledby="heading5_3" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> None of the above</p>
<p>Since the value which <code>impute</code> will choose to impute with
is random, the effect that it has on the standard deviation of
<code>vals</code> is unknown. If the missing values are filled with a
value close to the mean, this could reduce standard deviation; if they
are filled with a value far from the mean, this could increase standard
deviation. (Of course, the imputation will also shift the mean, so
without knowing details of the Series, it’s impossible to come up with
thresholds.) In any case, since the value for imputation is chosen at
random, none of these statements will <em>always</em> be true, and so
the correct answer is “none of the above.”</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<h2 id="section"><span class="math display"> </span></h2>
<h4
id="feedback-find-an-error-still-confused-have-a-suggestion-let-us-know-here.">👋
Feedback: Find an error? Still confused? Have a suggestion? Let us know
<a href="https://forms.gle/xK4DpWXh9rq8AKP37">here</a>.</h4>
<hr />
</body>
</html>
