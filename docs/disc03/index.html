<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Grouping, Pivoting, and Merging</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="../assets/theme.css" />
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css" />
</head>
<body>
<header id="title-block-header">
<h1 class="title">Grouping, Pivoting, and Merging</h1>
</header>
<p><link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>
<!-- add after bootstrap.min.css -->
<link rel="stylesheet" href="https://cdn.rawgit.com/afeld/bootstrap-toc/v1.0.1/dist/bootstrap-toc.min.css"/>
<!-- add after bootstrap.min.js or bootstrap.bundle.min.js -->
<script src="https://cdn.rawgit.com/afeld/bootstrap-toc/v1.0.1/dist/bootstrap-toc.min.js"></script></p>
<!-- for difficulty gauges-->
<script src="https://cdn.plot.ly/plotly-2.16.1.min.js"></script>
<!-- Global site tag (gtag.js) - Google Analytics -->
<!-- <script async src="https://www.googletagmanager.com/gtag/js?id=G-B947E6J6H4"></script> -->
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  // gtag('js', new Date());

  // gtag('config', 'G-B947E6J6H4');
</script>
<p><a href="../index.html">‚Üê return to study.practicaldsc.org</a></p>
<hr />
<p>The problems in this worksheet are taken from past exams in similar
classes. Work on them <strong>on paper</strong>, since the exams you
take in this course will also be on paper. <br><br>We encourage you to
complete this worksheet in a live discussion section. Solutions will be
made available after all discussion sections have concluded. You don‚Äôt
need to submit your answers anywhere.<br><br><b>Note: We do not plan to
cover all problems here in the live discussion section</b>; the problems
we don‚Äôt cover can be used for extra practice.</p>
<hr />
<h2 id="problem-1">Problem 1</h2>
<p>In this problem, we will work with the DataFrame <code>tv</code>,
which contains information about various TV shows available to watch on
streaming services. For each TV show, we have:</p>
<ul>
<li><code>"Title" (object)</code>: The title of the TV show.</li>
<li><code>"Year" (int)</code>: The year in which the TV show was first
released. (For instance, the show <em>How I Met Your Mother</em> ran
from 2005 to 2014; there is only one row for <em>How I Met Your
Mother</em> in <code>tv</code>, and its <code>"Year"</code> value is
2005.)</li>
<li><code>"Age" (object)</code>: The age category for the TV show. If
not missing, <code>"Age"</code> is one of <code>"all"</code>,
<code>"7+"</code>, <code>"13+"</code>, <code>"16+"</code>, or
<code>"18+"</code>. (For instance, <code>"all"</code> means that the
show is appropriate for all audiences, while `‚Äú18+‚Äù} means that the show
contains mature content and viewers should be at least 18 years
old.)</li>
<li><code>"IMDb" (float)</code>: The TV show‚Äôs rating on IMDb (between 0
and 10).</li>
<li><code>"Rotten Tomatoes" (int)</code>: The TV show‚Äôs rating on Rotten
Tomatoes (between 0 and 100).</li>
<li><code>"Netflix" (int)</code>: 1 if the show is available for
streaming on Netflix and 0 otherwise. The <code>"Hulu"</code>,
<code>"Prime Video"</code>, and <code>"Disney+"</code> columns work the
same way.</li>
</ul>
<p>The first few rows of <code>tv</code> are shown below (though
<code>tv</code> has many more rows than are pictured here).</p>
<center><img src='../assets/images/disc03/disc03-p1-df.png' width=65%></center>
<p>As you see in the first few rows of <code>tv</code>, some TV shows
are available for streaming on multiple streaming services. Fill in the
blanks so that the two expressions below, Expression 1 and Expression 2,
<strong>both</strong> evaluate to the <code>"Title"</code> of the TV
show that is available for streaming on the <strong>greatest number of
streaming services</strong>. Assume there are no ties and that the
<code>"Title"</code> column contains unique values.</p>
<p>Expression 1:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>tv.set_index(<span class="st">&quot;Title&quot;</span>).loc[__(a)__].T.<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">0</span>).idxmax()</span></code></pre></div>
<p>Expression 2:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>    (</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>        tv.assign(num_services<span class="op">=</span>tv.iloc[__(b)__].<span class="bu">sum</span>(__(c)__))</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>            .sort_values(<span class="st">&quot;num_services&quot;</span>)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>            .iloc[__(d)__]</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    )</span></code></pre></div>
<p><strong><em>Hint</em></strong>: <code>.T</code> transposes the rows
and columns of a DataFrame ‚Äî the indexes of <code>df</code> are the
columns of <code>df.T</code> and vice versa.</p>
<p>What goes in the blanks?</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse1" aria-expanded="true" aria-controls="collapse1">
Click to view the solution.
</button>
</h2>
<div id="collapse1" class="accordion-collapse collapse"
aria-labelledby="heading1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answers</strong>:</p>
<ul>
<li><ol type="a">
<li><code>:, "Netflix":</code> or some variation of that</li>
</ol></li>
<li><ol start="2" type="a">
<li><code>:, 5:</code> or some variation of that</li>
</ol></li>
<li><ol start="3" type="a">
<li><code>axis=1</code></li>
</ol></li>
<li><ol start="4" type="a">
<li><code>-1, 0</code></li>
</ol></li>
</ul>
<p>In Expression 1, keep in mind that <code>idxmax()</code> is a Series
method returns the index of the row with the maximum value. As such, we
can infer that Expression 1 sums the service-specific indicator columns
(that is, the columns <code>"Netflix"</code>, <code>"Hulu"</code>,
<code>"Prime Video"</code>, and <code>"Disney+"</code>) for each row and
returns the index of the row with the greatest sum. To do this, we need
the <code>loc</code> accessor to select all the service-specific
indicator columns, which we can do using <code>loc[:, "Netflix":]</code>
or
<code>loc[:, ["Netflix", "Hulu", "Prime Video", "Disney+"]]</code>.</p>
<p>When looking at Expression 2, we can split the problem into two
parts: the code inside the <code>assign</code> statement and the code
outside of it.</p>
<ul>
<li>Glancing at the code inside of the <code>assign</code> statement,
(and also noticing the variable <code>num_services</code>), we realize
that we, once again, want to sum up the values in the service-specific
indicator columns. We do this by first selecting the last four columns,
using <code>.iloc[:, 5:]</code> (notice the <code>iloc</code>), and then
summing over <code>axis=1</code>. We use <code>axis=1</code> (different
from <code>axis=0</code> in Expression 1), because unlike Expression 1,
we‚Äôre summing over each row, instead of each column. If there had not
been a <code>.T</code> in the code for Expression 1, we would‚Äôve also
used <code>axis=1</code> in Expression 1.</li>
<li>Finally, we need to select the <code>"Title"</code> of the last row
in DataFrame in Expression 2, because <code>sort_values</code> sorts in
ascending order by default. The last row has an integer position of -1,
and the <code>"Title"</code> column has an integer position of 0, so we
use <code>iloc[-1, 0]</code>.</li>
</ul>
</div>
</div>
</div>
</div>
<hr />
<h2 id="problem-2">Problem 2</h2>
<p>Suppose <code>df</code> is a DataFrame and <code>b</code> is any
boolean array whose length is the same as the number of rows of
<code>df</code>.</p>
<p>True or False: For any such boolean array <code>b</code>,
<code>df[b].shape[0]</code> is less than or equal to
<code>df.shape[0]</code>.</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> True</p></li>
<li><p><input type="radio" disabled="" /> False</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse2" aria-expanded="true" aria-controls="collapse2">
Click to view the solution.
</button>
</h2>
<div id="collapse2" class="accordion-collapse collapse"
aria-labelledby="heading2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> True</p>
<p>The brackets in <code>df[b]</code> perform a query, or filter, to
keep only the rows of <code>df</code> for which <code>b</code> has a
<code>True</code> entry. Typically, <code>b</code> will come from some
condition, such as the entry in a certain column of <code>df</code>
equaling a certain value. Regardless, <code>df[b]</code> contains a
subset of the rows of <code>df</code>, and <code>.shape[0]</code> counts
the number of rows, so <code>df[b].shape[0]</code> must be less than or
equal to <code>df.shape[0]</code>.</p>
</div>
</div>
</div>
</div>
<hr />
<h2 id="problem-3">Problem 3</h2>
<p>The <code>laptops</code> DataFrame contains information on various
factors that influence the pricing of laptops. Each row represents a
laptop, and the columns are:</p>
<ul>
<li><code>"Mfr" (str)</code>: the company that manufactures the laptop,
like ‚ÄúApple‚Äù or ‚ÄúDell‚Äù.</li>
<li><code>"Model" (str)</code>: the model name of the laptop, such as
‚ÄúMacBook Pro‚Äù.</li>
<li><code>"OS" (str)</code>: the operating system, such as ‚ÄúmacOS‚Äù or
‚ÄúWindows 11‚Äù.</li>
<li><code>"Screen Size" (float)</code>: the diagonal length of the
screen, in inches.</li>
<li><code>"Price" (float)</code>: the price of the laptop, in
dollars.</li>
</ul>
<p><br></p>
<h3 id="problem-3.1">Problem 3.1</h3>
<p><strong>Without using <code>groupby</code></strong>, write an
expression that evaluates to the average price of laptops with the
<code>"macOS"</code> operating system (the same quantity as above).</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading3_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse3_1" aria-expanded="true" aria-controls="collapse3_1">
Click to view the solution.
</button>
</h2>
<div id="collapse3_1" class="accordion-collapse collapse"
aria-labelledby="heading3_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong>
<code>laptops[laptops["OS"] == "macOS"]["Price"].mean()</code></p>
</div>
</div>
</div>
</div>
<p><br></p>
<p><br></p>
<h3 id="problem-3.2">Problem 3.2</h3>
<p><strong>Using <code>groupby</code></strong>, write an expression that
evaluates to the average price of laptops with the <code>"macOS"</code>
operating system.</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading3_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse3_2" aria-expanded="true" aria-controls="collapse3_2">
Click to view the solution.
</button>
</h2>
<div id="collapse3_2" class="accordion-collapse collapse"
aria-labelledby="heading3_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong>
<code>laptops.groupby("OS").mean()["Price"].loc["macOS"]</code></p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<h2 id="problem-4">Problem 4</h2>
<p>The DataFrame <code>items</code> describes various items available to
collect or purchase using bells, the currency used in the game
<em>Animal Crossing: New Horizons</em>.</p>
<p>For each item, we have:</p>
<ul>
<li><code>"Item" (str)</code>: The name of the item.</li>
<li><code>"Cost" (int)</code>: The cost of the item in bells. Items that
cost 0 bells cannot be purchased and must be collected through other
means (such as crafting).</li>
<li><code>"Location" (str)</code>: The store or action through which the
item can be obtained.</li>
</ul>
<p>The first 6 rows of <code>items</code> are below, though
<code>items</code> has more rows than are shown here.</p>
<center><img src="../assets/images/disc03/dsc10-fa23-quiz2-items.png" width=300></center>
<p>Fill in the blanks so that <code>count_1</code> and
<code>count_2</code> both evaluate to the number of items in
<code>items</code> with a <code>"Cost"</code> of 0.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>count_1 <span class="op">=</span> items.groupby(__(a)__).__(b)__().get(<span class="st">&quot;Item&quot;</span>).loc[__(c)__]</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>count_2 <span class="op">=</span> items[__(d)__].shape[<span class="dv">0</span>]</span></code></pre></div>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading4">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse4" aria-expanded="true" aria-controls="collapse4">
Click to view the solution.
</button>
</h2>
<div id="collapse4" class="accordion-collapse collapse"
aria-labelledby="heading4" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer</strong>:</p>
<ul>
<li><code>a</code>: <code>"Cost"</code></li>
<li><code>b</code>: <code>count</code></li>
<li><code>c</code>: <code>0</code></li>
<li><code>d</code>: <code>items.get("Cost") == 0</code></li>
</ul>
</div>
</div>
</div>
</div>
<hr />
<h2 id="problem-5">Problem 5</h2>
<p>The DataFrame <code>tv_excl</code> contains all of the information we
have for TV shows that are available to stream <em>exclusively</em> on a
single streaming service. The <code>"Service"</code> column contains the
name of the one streaming service that the TV show is available for
streaming on.</p>
<p>The first few rows of <code>tv_excl</code> are shown below (though,
of course, <code>tv_excl</code> has many more rows than are pictured
here). Note that <em>Being Erica</em> is not in <code>tv_excl</code>,
since it is available to stream on multiple services.</p>
<center><img src='../assets/images/wi23-midterm/tv-excl.png' width=65%></center>
<p>The DataFrame <code>counts</code>, shown in full below, contains the
number of TV shows for every combination of <code>"Age"</code> and
<code>"Service"</code>.</p>
<center><img src='../assets/images/wi23-midterm/pivot.png' width=40%></center>
<p>Given the above information, what does the following expression
evaluate to?</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>tv_excl.groupby([<span class="st">&quot;Age&quot;</span>, <span class="st">&quot;Service&quot;</span>]).<span class="bu">sum</span>().shape[<span class="dv">0</span>]</span></code></pre></div>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> 4</p></li>
<li><p><input type="radio" disabled="" /> 5</p></li>
<li><p><input type="radio" disabled="" /> 12</p></li>
<li><p><input type="radio" disabled="" /> 16</p></li>
<li><p><input type="radio" disabled="" /> 18</p></li>
<li><p><input type="radio" disabled="" /> 20</p></li>
<li><p><input type="radio" disabled="" /> 25</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading5">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse5" aria-expanded="true" aria-controls="collapse5">
Click to view the solution.
</button>
</h2>
<div id="collapse5" class="accordion-collapse collapse"
aria-labelledby="heading5" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer</strong>: 18</p>
<p>Note that the DataFrame <code>counts</code> is a pivot table, created
using
<code>tv_excl.pivot_table(index="Age", columns="Service", aggfunc="size")</code>.
As we saw in lecture, pivot tables contain the same information as the
result of grouping on two columns.</p>
<p>The DataFrame <code>tv_excl.groupby(["Age", "Service"]).sum()</code>
will have one row for every unique combination of <code>"Age"</code> and
<code>"Service"</code> in <code>tv_excl</code>. (The same is true even
if we used a different aggregation method, like <code>.mean()</code> or
<code>.max()</code>.) As <code>counts</code> shows us,
<code>tv_excl</code> contains every possible combination of a single
element in {<code>"13+"</code>, <code>"16+"</code>, <code>"18+"</code>,
<code>"7+"</code>, <code>"all"</code>} with a single element in
{<code>"Disney+"</code>, <code>"Hulu"</code>, <code>"Netflix"</code>,
<code>"Prime Video"</code>}, except for (<code>"13+"</code>,
<code>"Disney+"</code>) and (<code>"18+"</code>,
<code>"Disney+"</code>), which were not present in <code>tv_excl</code>;
if they were, they would have non-null values in
<code>counts</code>.</p>
<p>As such, <code>tv_excl.groupby(["Age", "Service"]).sum()</code> will
have <span class="math inline">20 - 2 = 18</span> rows, and
<code>tv_excl.groupby(["Age", "Service"]).sum().shape[0]</code>
evaluates to 18.</p>
</div>
</div>
</div>
</div>
<hr />
<h2 id="problem-6">Problem 6</h2>
<p>Suppose we have another DataFrame <code>more_flights</code> which
contains the same columns as <code>flights</code>, but different rows.
Define <code>merged</code> as follows.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>        merged <span class="op">=</span> flights.merge(more_flights, on <span class="op">=</span> <span class="st">&quot;airline&quot;</span>)</span></code></pre></div>
<p>Suppose that in <code>merged</code>, there are 108 flights where the
airline is <code>"United"</code>, and in <code>more_flights</code>,
there are 12 flights where the airline is <code>"United"</code>. If
<code>flights</code> has 15 rows in total, how many of these rows are
<strong>not</strong> for <code>"United"</code> flights? Give your answer
as an integer.</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading6">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse6" aria-expanded="true" aria-controls="collapse6">
Click to view the solution.
</button>
</h2>
<div id="collapse6" class="accordion-collapse collapse"
aria-labelledby="heading6" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> 6</p>
</div>
</div>
</div>
</div>
<hr />
<h2 id="problem-7">Problem 7</h2>
<p>For your convenience, the first few rows of <code>tv</code> are shown
again below.</p>
<center><img src='../assets/images/wi23-midterm/data-info-wi23-mt.png' width=65%></center>
<p>For the purposes of this question only, suppose we have also access
to another similar DataFrame, <code>movies</code>, which contains
information about a variety of movies. The information we have for each
movie in <code>movies</code> is the same as the information we have for
each TV show in <code>tv</code>, except for IMDb ratings, which are
missing from <code>movies</code>.</p>
<p>The first few rows of <code>movies</code> are shown below (though
<code>movies</code> has many more rows than are pictured here).</p>
<center><img src='../assets/images/wi23-midterm/movies-dinfo-wi23-mt.png' width=65%></center>
<p><br></p>
<h3 id="problem-7.1">Problem 7.1</h3>
<p>The function <code>total_null</code>, defined below, takes in a
DataFrame and returns the total number of null values in the
DataFrame.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>total_null <span class="op">=</span> <span class="kw">lambda</span> df: df.isna().<span class="bu">sum</span>().<span class="bu">sum</span>()</span></code></pre></div>
<p>Consider the function <code>delta</code>, defined below.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> delta(a, b):</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    tv_a <span class="op">=</span> tv.head(a)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    movies_b <span class="op">=</span> movies.head(b)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    together <span class="op">=</span> pd.concat([tv_a, movies_b])</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> total_null(together) <span class="op">-</span> total_null(tv_a) <span class="op">-</span> total_null(movies_b)</span></code></pre></div>
<p>Which of the following functions is equivalent to
<code>delta</code>?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> <code>lambda a, b: a</code></p></li>
<li><p><input type="radio" disabled="" /> <code>lambda a, b: b</code></p></li>
<li><p><input type="radio" disabled="" /> <code>lambda a, b: 9 * a</code></p></li>
<li><p><input type="radio" disabled="" /> <code>lambda a, b: 8 * b</code></p></li>
<li><p><input type="radio" disabled="" /> <code>lambda a, b: min(9 * a, 8 * b)</code></p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading7_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse7_1" aria-expanded="true" aria-controls="collapse7_1">
Click to view the solution.
</button>
</h2>
<div id="collapse7_1" class="accordion-collapse collapse"
aria-labelledby="heading7_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer</strong>: <code>lambda a, b: b</code></p>
<p>Let‚Äôs understand what each function does.</p>
<ul>
<li><code>total_null</code> just counts all the null values in a
DataFrame.</li>
<li><code>delta</code> concatenates the first <code>a</code> rows of
<code>tv</code> with the first <code>b</code> rows of
<code>movies</code> <strong>vertically</strong>, that is, on top of one
another (over axis 0). It then returns the difference between the total
number of null values in the concatenated DataFrame and the total number
of null values in the first <code>a</code> rows of <code>tv</code> and
first <code>b</code> rows of <code>movies</code> ‚Äì in other words, it
returns <strong>the number of null values that were added as a result of
the concatenation</strong>.</li>
</ul>
<p>The key here is recognizing that <code>tv</code> and
<code>movies</code> have all of the same column names,
<strong>except</strong> <code>movies</code> doesn‚Äôt have an
<code>"IMDb"</code> column. As a result, when we concatenate, the
<code>"IMDb"</code> column will contain null values for every row that
was originally from <code>movies</code>. Since <code>b</code> rows from
<code>movies</code> are in the concatenated DataFrame, <code>b</code>
new null values are introduced as a result of the concatenation, and
thus <code>lambda, a, b: b</code> does the same thing as
<code>delta</code>.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-7.2">Problem 7.2</h3>
<p>Fill in the blank to complete the implementation of the function
<code>size_of_merge</code>, which takes a string <code>col</code>,
corresponding to the name of a <strong>single</strong> column that is
shared between <code>tv</code> and <code>movies</code>, and returns the
<strong>number of rows in</strong> the DataFrame
<code>tv.merge(movies, on=col)</code>.</p>
<ul>
<li><p>For instance, <code>size_of_merge("Year")</code> should return
the number of rows in <code>tv.merge(movies, on="Year")</code>.</p></li>
<li><p>The purpose of this question is to have you think conceptually
about how merges work. As such, <strong>solutions containing
<code>merge</code> or <code>concat</code> will receive 0
points.</strong></p></li>
</ul>
<p><strong>What goes in the blank below?</strong></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> size_of_merge(col):</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (____).<span class="bu">sum</span>()</span></code></pre></div>
<p><strong><em>Hint</em></strong>: Consider the behavior below.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> s1 <span class="op">=</span> pd.Series({<span class="st">&#39;a&#39;</span>: <span class="dv">2</span>, <span class="st">&#39;b&#39;</span>: <span class="dv">3</span>})</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> s2 <span class="op">=</span> pd.Series({<span class="st">&#39;c&#39;</span>: <span class="dv">4</span>, <span class="st">&#39;a&#39;</span>: <span class="op">-</span><span class="dv">1</span>, <span class="st">&#39;b&#39;</span>: <span class="dv">4</span>})</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> s1 <span class="op">*</span> s2</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>a    <span class="op">-</span><span class="fl">2.0</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>b    <span class="fl">12.0</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>c     NaN</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>dtype: float64</span></code></pre></div>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading7_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse7_2" aria-expanded="true" aria-controls="collapse7_2">
Click to view the solution.
</button>
</h2>
<div id="collapse7_2" class="accordion-collapse collapse"
aria-labelledby="heading7_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer</strong>:
<code>tv[col].value_counts() * movies[col].value_counts()</code></p>
<p><code>tv.merge(movies, on=col)</code> contains one row for every
‚Äúmatch‚Äù between <code>tv[col]</code> and <code>movies[col]</code>.
Suppose, for example, that <code>col="Year"</code>. If
<code>tv["Year"]</code> contains 30 values equal to 2019, and
<code>movies["Year"]</code> contains 5 values equal to 2019,
<code>tv.merge(movies, on="Year")</code> will contain <span class="math inline">30 \cdot 5 = 150</span> rows in which the
<code>"Year"</code> value is equal to 2019 ‚Äì one for every combination
of a 2019 row in <code>tv</code> and a 2019 row in
<code>movies</code>.</p>
<p><code>tv["Year"].value_counts()</code> and
<code>movies["Year"].value_counts()</code> contain, respectively, the
frequencies of the unique values in <code>tv["Year"]</code> and
<code>movies["Year"]</code>. Using the 2019 example from above,
<code>tv["Year"].value_counts() * movies["Year"].value_counts()</code>
will contain a row whose index is 2019 and whose value is 150, with
similar other entries for the other years in the two Series. (The hint
is meant to demonstrate the fact that no matter how the two Series are
sorted, the product is done element-wise by matching up indexes.) Then,
<code>(tv["Year"].value_counts() * movies["Year"].value_counts()).sum()</code>
will sum these products across all years, ignoring null values.</p>
<p>As such, the answer we were looking for is
<code>tv[col].value_counts() * movies[col].value_counts()</code>
(remember, <code>"Year"</code> was just an example for this
explanation).</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<h2 id="section"><span class="math display"> </span></h2>
<h4
id="feedback-find-an-error-still-confused-have-a-suggestion-email-us-at-rampureumich.edu.">üëã
Feedback: Find an error? Still confused? Have a suggestion? Email us at
rampure@umich.edu.</h4>
<hr />
</body>
</html>
