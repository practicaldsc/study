# BEGIN PROB

In this problem, we'll work with the DataFrame `dogs`, which contains one row for every registered pet dog in Zurich, Switzerland in 2017.

The first few rows of `dogs` are showhn below, but `dogs` has many more rows tan are shown.

<center><img src="../../assets/images/disc02/disc02-p1-df.png" width=750></center>

<br>

- `"owner_id" (int)`: A unique ID for each owner. Note that, for example, there are two rows in the preview for `4215`, meaning that owner has at least 2 dogs. **Assume that if an `"owner_id"` appears in `dogs` multiple times, the corresponding `"owner_age"`, `"owner_sex"`, and `"district"` are always the same.**
- `"owner_age" (str)`: The age group of the owner; either `"11-20"`, `"21-30"`, ..., or `"91-100"` (9 possibilities in total).
- `"owner_sex" (str)`: The birth sex of the owner; either `"m"` (male) or `"f"` (female).
- `"district" (int)`: The city district the owner lives in; a positive integer between `1` and `12` (inclusive).
- `"primary_breed" (str)`: The primary breed of the dog.
- `"secondary_breed" (str)`: The secondary breed of the dog. If this column is not null, the dog is a "mixed breed" dog; otherwise, the dog is a "purebred" dog.
- `"dog_sex" (str)`: The birth sex of the dog; either `"m"` (male) or `"f"` (female).
- `"birth_year" (int)`: The birth year of the dog.

# BEGIN SUBPROB

Suppose `"21-30"` is the most common value in the `"owner_age"` column.
Just for this part, suppose we also have access to a `"owner_age_years"`
column that contains the actual age of each owner in years, e.g. `36`
instead of `"31-40"`.

True or False: The most common value in the `"owner_age_years"` column
must be between `21` and `30`, inclusive.

( ) True
( ) False

# BEGIN SOLUTION

**Answer**: It could be the case that 21-30 is the most common age category, but 33 is the single most common age. What if everyone in the 31-40 age category is aged 33, but everyone in the 21-30 age category is "spaced out"?

<average>71</average>

# END SOLUTION

# END SUBPROB

# BEGIN SUBPROB

Fill in the blank so that `most_common` evaluates to the most common
district in `dogs`. Assume there are no ties.

```py
most_common = ____
```

# BEGIN SOLUTION

**Answer**:

```py
dogs["district"].value_counts().idxmax()
```

Above, we presented one possible solution, but there are many:

- `dogs["district"].value_counts().idxmax()`
- `dogs["district"].value_counts().index[0]`
- `dogs.groupby("district").size().sort_values(ascending=False).index[0]`
- `dogs.groupby("district").count()["owner_id"].sort_values(ascending=False).index[0]`

# END SOLUTION

# END SUBPROB

# BEGIN SUBPROB

Fill in the blank so that `female_breeds` evaluates to a Series
containing the primary breeds of all female dogs.

```py
female_breeds = dogs.____
```

# BEGIN SOLUTION

**Answer**:

```py
loc[dogs["dog_sex"] == "f", "primary_breed"]
```

Another possible answer is:

```py
query("dog_sex == 'f'")["primary_breed"]`

Note that the question _didn't_ ask for unique primary breeds.

# END SOLUTION

# END SUBPROB

# BEGIN SUBPROB

Fill in the blank so that `midpoints` evaluates to a Series that contains the midpoint of each dog owner's age group as a float. For example, the midpoint of the age group `"51-60"` is `55.5`. Your answer must fit on one line, and cannot use the `def` keyword.

```py
midpoints = dogs["owner_age"].____
```

# BEGIN SOLUTION

**Answer**: 

```py
str.split("-").str[0].astype(float) + 4.5
```

There are many possible solutions. Many students tried to average the two numbers, which is correct:

```py
apply(lambda x: 0.5 * (int(x.split("-")[0]) + int(x.split("-")[1])))
```

However, we thought it's much easier to just add 4.5 to the first number (which is what the "answer" presented does), or even concatenate the first digit with the string "5.5" â€“ these are all equivalent to the midpoint.

# END SOLUTION

# END SUBPROB

# END PROB